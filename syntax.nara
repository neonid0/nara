# comments start with `#`

# variable declarations:

val x = 4; # immutable
mut y = 8; # mutable

# you can also specify the type
val my_unit: nil = (); # nil can be referred to as `()`
mut my_bool: bool = true;
# nil is a void type, meaning it has no values other than itself
# types referred as lowercase are primitive types,
# and types referred to as titlecase are user-defined types
# for predefined types, you can use the following:
# - nil: the void type, has no values
# - bool: a boolean type, has two values: true and false
# - int: a 64-bit signed integer type
# - float: a 64-bit floating point type
# - str: a UTF-8 encoded string type
# - char: a single UTF-8 character type
# - opt(T): an optional type, which can either be none or some(T)
# - res(T, E): a result type, which can either be ok(T) or err(E)
# - list(T): a list type, which is a linked list of T values
# - map(K, V): a map type, which is a hash map of K to V values
# - tuple(T1, T2, ...): a tuple type, which is a fixed-size collection of values of different types
# - enum: a user-defined type that can have multiple variants, each with its own fields
# - type: a user-defined type that can have fields and methods, similar to a struct in other languages
# - proto: a protocol type, which is a user-defined type that can have methods, similar to a trait in Rust or a protocol in Swift
# - impl: an implementation of a protocol for a user-defined type, similar to an extension in Swift or an implementation in Rust
# - use: a module import statement, which allows you to import types and functions from other modules
# - unsafe: a block expression that allows you to perform unsafe operations, similar to an unsafe block in Rust
# - *: a pointer type, which is a reference to a value of a type, similar to a pointer in C or C++
# - fn: a function type, which is a user-defined type that can have parameters and a return type, similar to a function in other languages

# definition and initialization can also be separate:
my_var: int;
# -- Snip --
my_var = 7;

# block expressions are just like block expressions in rust!
# the entire expression gets the value of the last expression statement
val foo: int = {
  val x = 4;
  val y: int = 8;
  return x + y
}

#functions are defined with the `fn` keyword, and can be either
fn foo(param1: int, param2: str): int {
  val x: int = 4;
  val y = 8;
  return x + y + param2
}
fn oper(a: int, b: str) 4 + 3
#function calls
foo(12, "Hello World")
foo(param1 = 12, param2 = "Hello World") # named arguments are supported
val x = foo(12, "Hello World");

# Lambda functions are defined with the `->` syntax
# functions can be just expressions and are assigned to variables as such
# format looks like <params> -> <return_type>: <expr>
() -> 1 + 3 # this is a lambda function that returns 4
param1, param2 -> 1 + 3 # you can also use params without assume to a variable
val add = () -> int: 1 + 3; # Parantheses are required if there are no parameters
mut add = param1: int, param2: int -> int: param1 + param2;

# <expr> can be a block expression: (<params>) -> <return_type>: { <body> }
val add_with_block = (first: int, second: int) -> int: {
  return first + second
};

# ==== NOT INCLUDED ====
# A good solution from [kiahjh](https://github.com/kiahjh)
# idk what is the best way to handle function parameters, so here's a compromise:
# parameters use this syntax: <callsite_name> <implementation_name>: <type>
# inside the function body, you use <implementation_name>, but at the callsite
# you use <callsite_name> as the label.
# if you want to use the same name in both places, just leave off <callsite_name>.
# if you don't want to label the argument at the callsite, use `~`:
# ~<implementation_name>: <type>
# add(3, to: 7)
# add_with_block(3, to: 7)


# if expressions look like if <condition>: <expr>
# they return the type of <expr> if followed by an else
# otherwise if there's no else, they become opt(typeof expr)
val x = if y > 0 ? "hi" : "bye"; # type of x is str
mut x = if y > 0 ? "hi";         # type of x is opt(str)

# while loops look just like if statements: while <condition> { <expr> }
while 5 > 3 && 12 < 20 || false -> print("hi")
while 5 > 3 {
    do_something()
} # Block statements are also supported

# i couldn't choose syntax for loops, so here's what i came up with:
# loop loops just look like loop( <epxr> )
loop(print("hi"))
loop({
  print("hi")
}) # Block statements are also supported
# for loops look like for <item> in <iterator> <expr>
for num in 0..3 print(item)
for num in 0..5 { print(item) } # Block statements are also supported
for table in table_of_contents {
  print(table)
} # iterating over an array or a map


# all loops can break with a value: `break <expr>` and
# have `break` that just return unit by default
# and have a continue expression that just returns unit and
# continue to next item as well
loop({
  if some_condition {
    break 42 # can return 42 as a value
  }
  if other_condition {
    continue # returns unit and continues
  }
  print("hi")
})

while condition {
  if some_condition {
    break # returns unit
  }
  if other_condition {
    continue # returns unit and continues
  }
  print("hi")
}


# try expressions look like try { <expr> } catch <error_type> { <expr> }
# they return the return type of <expr> if followed by a catch
try {
  val result = might_error(4) # might_error is a function that returns a res(int, str)
  print(result.ok) # if the result is ok, this will print the value
} catch error {
  print("Error: " + error) # if the result is an error, this will print the error message
}



# in Nara, every user-defined type is either an enum or a tuple, but enums
# can have fields, which can give them struct-like behavior. this means that
# there's no clear distinction in Nara between product and sum types,
# and types can have properties of both
type Worker {
  @Developer
  @NoJob
  @Other(String)

  name: str 
  age: int 
}

# constructing a worker:
val me = Worker@Developer {
  name = "Kiah",
  age = 20,
}
val my_brother = Worker@Other("home builder") {
  name = "Ezra",
  age = 23,
}
# calling a function on a worker:
fn greet(worker: Worker): str {
  match worker {
    @Developer: "Hello, developer " + worker.name
    @NoJob: "Hello, unemployed person"
    @Other(job): "Hello, " + job + " " + worker.name
  }
}

# types can also have constant values including functions (methods)
type Penguin {
  $Emperor       # `$` means Emperor is the default variant
  @LittleBlue
  @King
  @Chinstrap
  @Adele

  swim = self -> print("sploosh")
  fn swim_with_speed(speed: int) {
    print("sploosh at speed " + speed.to_string())
  }
  is_friendly: bool = true
}


val lil_blue = Penguin@LittleBlue
lil_blue.swim() # prints "sploosh"
lil_blue.is_friendly # returns true

val emperor = Penguin$ {} # makes an Emperor penguin, since Emperor was marked with `$`

# if you don't specify any variants for your type, you get one for free
# called `$Default`, which:
type Creature {
  can_bite: bool
  weight_in_kg: int
}
val scary_creature = Creature {
  can_bite = true,
  weight_in_kg = 200,
}

# btw, all anonymous type instantiations (when there's only one variant) are prefixed with `$` as well, so you can have something like:
val x = ${ foo = 4, bar = 8, can = "Hello" } # infered as { foo: Int bar: Int, can: str }
val y = $(34, 4) # infered as (Int, Int)

# fields can have default values as well:
type Person {
  name: str
  age: int
  num_eyes: int = 2
}
val me = Person {
  name = "Kiah",
  age = 20,
}

val blackbeard = Person {
  name = "blackbeard",
  age = 40,
  num_eyes = 1,
}

# you can nest types:
type Foo {
  bar: Bar

  type Bar {
    baz: int
  }
}
val bar = Foo.Bar { 
    baz = 8
}

# generics don't need to be declared like in many languages
# they start with a ' and are lowercase
val identity =  x: 'a -> 'a: x # yes, this is a lambda expression that returns its argument

identity(4) # return integer 4

# protocols are like protocols in Swift, or traits in Rust
# to demonstrate them, we'll use this functional list example
type List('a) {
  @Empty
  @Cons({
    head: 'a
    tail: *list('a) # * is a pointer type, similar to C/C++
  })
}
proto Iterator('a) { 
  type Item

  next: fn (~'a) -> Item
}
impl Iterator(list('a)) {
  type Item 'a

  next = fn (~self) -> opt(Item): {
    match self {
      @Empty: None
      @Cons(${ head, tail }): {
        self = tail
        head
      }
    }
  }
}

# optionals
val weird_fn = x: int -> opt(int): {
  if x > 8 ? some(x * x) : none
  # because of how if expressions work, the above line is equivalent to this:
  # if x > 8 ? x * x
}

# errors
val might_error = x: int -> res(int, str): {
  if x > 8 ? ok(x * x) : err("whoops too small")
}

# modules
# just like in rust, but with '.' instead of '::'
use Syntax.{
  List.{Foo, Bar},
    might_error,
}
use Syntax.List.Foo
use Syntax.List.{Foo, Bar} # you can use a single import statement to import multiple things

# ownership
# Nara is memory safe!
# To pull this off, it uses a Rust/Mojo-inspired ownership model.
# Every value is owned by exactly one variable at a time, but can be
# accessed and even mutated by passing it along by reference, as long
# as the reference doesn't outlive the variable that owns the value.
# Variables are destroyed by Nara when they go out of scope.

# function parameters are prefixed with one of the following three options:
# - &: (the default value, if you leave off the prefix, this is used)
#      an immutable reference to a value (& in Rust)
# - ~: a mutable reference to a value (&mut in Rust)
# - _: an owned value (the default in Rust)

val example_function = &x: str, ~y: int, z: bool -> { <expr> }

val x = "foo"
mut y = 89  # y has to be mutable, or it can't be passed as a mutable reference
val z = true
example_function(x, y, z)
# z can't be used here because it was consumed by the function

# another good solution from [kiahjh](https://github.com/kiahjh)
# for owned arguments, just like in Mojo, there are three cases:
# - you pass in a variable prefixed with `^`, which ends the lifetime of that variable moves it into the scope of the function
# - you don't use `^`, which will copy the variable over if it implements the `Copiable` protocol, otherwise it will be a compiler error
# - passing a newly-created value, like a literal or the result of a function call

# variables are allocated and deallocated by the compilier

# unsafe blocks
# just block expressions prepended with the `unsafe` keywords that allow unsafe operations
unsafe {
  return 2 + 2 # just an example, this obviously isn't unsafe
}

# raw pointers
mut x = 8
xp : *Int : x.&
consumes(^x) # x dies, so xp is pointing to garbage

# unsafe blocks are required for pointer dereferencing, but not for pointer creation
unsafe {
  print(xp.*)
  xp.* = 30 # pointer derefs are valid lvalues
}
fn dangerous_function(~x: *Int) unsafe {
    print(x.*) # dereferencing a pointer is unsafe
    x.* = 42 # this is also unsafe, but it works
}



